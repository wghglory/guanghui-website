---
title: Angular Form
topics:
  - angular
date: 2022-07-15
excerpt: Angular Form
cover:
  topic: Angular
  title: Angular
  subtitle: Form
---

## Useful Basic FormControl Members

<Table
  columns={['Name', 'Description']}
  data={[
    ['value', 'return the current value of the form control, defined using the any type.'],
    ['setValue(value)', 'sets the value of the form control.'],
    ['valueChanges', 'returns an Observable<any>, through which changes can be observed.'],
    ['enabled', 'returns true if the form control is enabled.'],
    ['disabled', 'returns true if the form control is disabled.'],
    ['enable()', 'enables the form control.'],
    ['disable()', 'disables the form control.'],
    [
      'reset(value)',
      'resets the form control, with an optional value. The form control will be reset to its default state if the value argument is omitted.',
    ],
  ]}
/>

## Managing Control State

<Table
  columns={['Name', 'Description']}
  data={[
    ['untouched', 'returns true if the HTML element is untouched, meaning that the element has not been selected.'],
    [
      'touched',
      'This property returns true if the HTML element has been touched, meaning that the element has been selected.',
    ],
    ['markAsTouched()', 'marks the element as touched.'],
    ['markAsUntouched()', 'marks the element as untouched.'],
    ['pristine', 'returns true if the element contents have not been edited by the user.'],
    ['dirty', 'returns true if the element contents have been edited by the user'],
    ['markAsPristine()', 'marks the element as pristine.'],
    ['markAsDirty()', 'marks the element as dirty'],
  ]}
/>

## FormControl Members for Managing Validators

<Table
  columns={['Name', 'Description']}
  data={[
    [
      'validator',
      'returns a function that combines all of the configured validators so that the form control can be validated with a single function call',
    ],
    ['hasValidator(v)', 'returns true if the form control has been configured with the specified validator.'],
    [
      'setValidators(v)',
      'sets the form control validators. The argument can be a single validator or an array of validators',
    ],
    ['addValidators(v)', 'adds one or more validators to the form control'],
    ['removeValidators(v)', 'removes one or more validators from the control'],
    ['clearValidators()', 'removes all of the validators from the form control'],
  ]}
/>

## FormControl Members for Managing Validation State

- status: VALID, INVALID, PENDING, or DISABLED
- statusChanges: returns an `Observable<FormControlStatus>`, which will emit a FormControlStatus value when the state of
  the form control changes
- valid
- invalid
- pending: returns true if the form control’s value is being validated asynchronously
- errors: returns a ValidationErrors object that contains the errors generated by the form control’s validators, or null
  if there are no errors.
- getError(v): returns the error message, if there is one, for the specified validator. This method accepts an optional
  path for use with nested form controls
- hasError(v): returns true if the specified validator has generated an error message. This method accepts an optional
  path for use with nested form controls
- setErrors(errs): This method is used to add errors to the form control’s validation status, which is useful when
  performing manual validation in the component. This method accepts an optional path for use with nested form controls,

## Simple Form - FormControl

```ts
export class FormComponent {
  nameField: FormControl = new FormControl('', {
    validators: [Validators.required, Validators.minLength(3), Validators.pattern('^[A-Za-z ]+$')],
    updateOn: 'change', // change(default), blur, submit
  });

  ngOnInit() {
    this.nameField.statusChanges.subscribe((newStatus) => {
      if (newStatus == 'INVALID' && this.nameField.errors != null) {
        const errs = Object.keys(this.nameField.errors).join(', ');
        this.messageService.reportMessage(new Message(`INVALID: ${errs}`));
      } else {
        this.messageService.reportMessage(new Message(newStatus));
      }
    });
    // this.nameField.valueChanges.subscribe((newValue) => {
    //   this.messageService.reportMessage(new Message(newValue || '(Empty)'));
    // });
  }
}
```

app/shared/validation/validationHelper.pipe.ts:

```ts
import {Pipe} from '@angular/core';
import {FormControl, ValidationErrors} from '@angular/forms';

@Pipe({name: 'validationFormat'})
export class ValidationHelper {
  transform(source: any, name: any): string[] {
    if (source instanceof FormControl) {
      return this.formatMessages((source as FormControl).errors, name);
    }
    return this.formatMessages(source as ValidationErrors, name);
  }

  formatMessages(errors: ValidationErrors | null, name: string): string[] {
    let messages: string[] = [];

    for (let errorName in errors) {
      switch (errorName) {
        case 'required':
          messages.push(`You must enter a ${name}`);
          break;
        case 'minlength':
          messages.push(`A ${name} must be at least ${errors['minlength'].requiredLength} characters`);
          break;
        case 'pattern':
          messages.push(`The ${name} contains illegal characters`);
          break;
      }
    }
    return messages;
  }
}
```

app/shared/shared.module.ts:

```ts
import {CommonModule} from '@angular/common';
import {NgModule} from '@angular/core';

import {ValidationHelper} from './validation/validationHelper.pipe';

@NgModule({
  declarations: [ValidationHelper],
  imports: [CommonModule],
  exports: [ValidationHelper],
})
export class SharedModule {}
```

form.component.html:

```diff
<div class="form-group">
  <label>Name</label>
  <input class="form-control" name="name" [formControl]="nameField" #name="ngForm" />

  <ul class="text-danger list-unstyled mt-1" *ngIf="name.dirty && name.invalid">
+    <li *ngFor="let err of name.errors | validationFormat:'name'">{{ err }}</li>
  </ul>
</div>
```

## FormGroup Members for Adding and Removing Controls

<Table
  columns={['Name', 'Description']}
  data={[
    [
      'addControl(name, ctrl)',
      'adds a control to the FormGroup with the specified name. No action is taken if there is already a control with this name',
    ],
    [
      'setControl(name, ctrl)',
      'adds a control to the FormGroup with the specified name, replacing any existing control with this name',
    ],
    ['removeControl(name)', 'removes the control with the specified name'],
    ['controls', 'returns a map containing the controls in the group, using their names as keys'],
    ['get(name)', 'returns the control with the specified name'],
  ]}
/>

## FormGroup Methods for Managing Control Values

<Table
  columns={['Name', 'Description']}
  data={[
    [
      'value',
      'returns an object containing the values of the form controls in the group, using the names given to each control as the names of the properties.',
    ],
    [
      'setValue(val)',
      'sets the contents of the form controls using an object, whose property names correspond to the names given to each control. The specified value object must define properties for all the form controls in the group.',
    ],
    [
      'patchValue(val)',
      'sets the contents of the form controls using an object, whose property names correspond to the names given to each control. Unlike the setValue method, values are not required for all form controls.',
    ],
    [
      'reset(val)',
      'resets the form to its pristine and untouched state and uses the specified value to populate the form controls.',
    ],
  ]}
/>

### Displaying Validation Messages with a Form Group

<Table
  columns={['Name', 'Description']}
  data={[
    [
      'getError(v, path)',
      'returns the error message, if there is one, for the specified validator. The optional path argument is used to identify the control.',
    ],
    [
      'hasError(v, path)',
      'returns true if the specified validator has generated an error message. The optional path argument is used to identify the control.',
    ],

]} />

`form.getError("required", "category")` will return category control's required error message if any. But this is not
very useful. Let's create a reusable and custom structural directives to display all errors for a control.

## Custom directive to display all errors for a control ❤️

Create src/app/shared/validation/validationErrors.directive.ts and import/export in the shared.module:

```ts
import {Directive, Input, OnInit, TemplateRef, ViewContainerRef} from '@angular/core';
import {FormGroup} from '@angular/forms';

import {ValidationHelper} from './validationHelper';

/**
 * A structural directive to generate validation errors for a formGroup field control
 */
@Directive({selector: '[validationErrors]'})
export class ValidationErrorsDirective implements OnInit {
  constructor(private container: ViewContainerRef, private template: TemplateRef<unknown>) {}

  @Input('validationErrorsControl') name = ''; // control: 'xxx' from <li *validationErrors="productForm; control: 'name'; let err">
  @Input('validationErrorsLabel') label?: string; // label: 'xxx'
  @Input('validationErrors') formGroup?: FormGroup; // e.g. productForm

  ngOnInit() {
    const formatter = new ValidationHelper();

    if (this.formGroup && this.name) {
      const control = this.formGroup?.get(this.name);

      if (control) {
        control.statusChanges.subscribe(() => {
          if (this.container.length > 0) {
            this.container.clear();
          }
          if (control && control.dirty && control.invalid && control.errors) {
            formatter.formatMessages(control.errors, this.label ?? this.name).forEach((err) => {
              this.container.createEmbeddedView(this.template, {$implicit: err});
            });
          }
        });
      }
    }
  }
}
```

Now our form.component.html can use the directive to show all errors for a specific control:

```diff
<input class="form-control" formControlName="price" />
<ul class="text-danger list-unstyled mt-1">
+  <li *validationErrors="productForm; control: 'price'; let err">{{ err }}</li>
</ul>
```

## Nested FormGroup and Validation

```diff
productForm: FormGroup = new FormGroup({
  name: new FormControl('', {
    validators: [Validators.required, Validators.minLength(3), Validators.pattern('^[A-Za-z ]+$')],
    updateOn: 'change',
  }),
  category: new FormControl('', {validators: Validators.required}),
  price: new FormControl('', {validators: [Validators.required, Validators.pattern('^[0-9.]+$')]}),
+  details: new FormGroup({
+    supplier: new FormControl('', {validators: Validators.required}),
+    keywords: new FormControl('', {validators: Validators.required}),
+  }),
});
```

```html
<ng-container formGroupName="details">
  <div class="form-group">
    <label>Supplier</label>
    <input class="form-control" formControlName="supplier" />
    <ul class="text-danger list-unstyled mt-1">
      <li *validationErrors="productForm; control: 'details.supplier'; label: 'supplier'; let err">{{ err }}</li>
    </ul>
  </div>
  <div class="form-group">
    <label>Keywords</label>
    <input class="form-control" formControlName="keywords" />
    <ul class="text-danger list-unstyled mt-1">
      <li *validationErrors="productForm; control: 'details.keywords'; label: 'keyword'; let err">{{ err }}</li>
    </ul>
  </div>
</ng-container>
```
